---
layout: single
title: "CoreJS this"
---

# this
대부분의 객체지향 언어에서 this는 클래스로 생성한 인스턴스 객체를 의미한다. 자바스크립트에서의 this는 어디서든 사용할 수 있다. 상황에 따라 this가 바라보는 대상이 달라진다.     
함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.      

자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 생성 된다. 즉 **this는 함수를 호출할 때 결정**된다.   

### 전역 공간에서의 this
전역 공간에서 this는 전역 객체를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문.   

브라우저 환경 : window    
Node.js 환경 : global     

**전역 공간에서 발생하는 특징** : 전역변수를 선언하면 JS엔진은 이를 전역객체의 프로퍼티로도 할당한다. 변수이면서 객체의 프로퍼티인 셈.   

**자바스크립트의 모든 변수는 특정 객체의 프로퍼티**로서 동작 한다. 특정 객체란 실행 컨텍스트의 `LexicalEnvironment` 이다. 실행 컨텍스트는 변수를 수집해서 L.E의 프로퍼티로 저장한다. 전역 컨텍스트의 경우 L.E는 전역객체를 그대로 참조한다.    

### 메서드로서 호출할 때 그 메서드 내부에서의 this
어떤 함수를 실행하는 가장 일반적인 방법 : 함수로서 호출, 메서드로서 호출    

#### 함수 vs 메서드
함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 **독립성**에 있다.     
함수 : 그 자체로 독립적인 기능을 수행    
메서드 : 자신을 호출한 대상 객체에 관한 동작을 수행      

어떤 함수를 객체의 프로퍼티에 할당한다고 무조건 메서드가 되는것이 아니라, `메서드`는 객체의 메서드로서 호출할 경우에 `메서드`로 동작하고, 그렇지 않으면 `함수`로 동작한다.     

#### '함수로서 호출'과 '메서드로서 호출'을 어떻게 구분 할까?
함수 앞에 점(.)이 있는지 여부로 구분할 수 있다. 함수 앞에 점이 없으면 함수로서 호출, method 앞에 점이 있으면 메서드로서 호출한 것!   
(대괄호 표기법에서는 함수 이름 앞에 객체가 명시돼 있는 경우에 메서드로 호출한 것.)      

#### 메서드 내부에서의 this
`this`에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 `this`가 되는 것.    

### 함수로서 호출할 때 그 함수 내부에서의 this
함수 내부에서의 this : 함수에서의 `this`는 전역 객체를 가리킨다.    
메서드의 내부함수에서의 this : 내부함수를 함수로서 호출한 것이면 전역객체, 메서드로서 호출한 것이면 점(.) 앞의 객체를 바라본다.      

#### this를 바인딩하지 않는 함수
ES5에서는 변수에 this를 저장해서 내부함수에서 활용하는 방법으로 this를 우회했다. ES6에서는 this를 바인딩하지 않는 화살표 함수(arrow function)를 새로 도입했다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다.    

### 콜백 함수 호출 시 그 함수 내부에서의 this
**콜백 함수란?** 함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라고 부른다.     

콜백 함수를 호출할 때 대상이 될 this를 지정하지 않은 경우의 this는 전역객체를 바라본다.    
어떠한 메서드가 콜백 함수를 호출할 때 자신의 this를 상속한다면 메서드명의 점(.) 앞부분이 곧 this가 된다.     

### 생성자 함수 내부에서의 this
**생성자 함수**란? 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수이다. 객체지향 언어에서는 `클래스(class)`, 클래스를 통해 만든 객체를 `인스턴스(instance)`라고 한다. 프로그래밍적으로 '생성자'는 **구체적인 인스턴스를 만들기 위한** 일종의 **틀**이다. new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다. 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다.    
생성자 함수를 호출(new 명령어와 함께 함수를 호출) -> 생성자의 prototype 프로퍼티를 참조하는 __proto__ 라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여   

### call 메서드
call 메서드 : 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령. 이때 call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 한다.    
함수를 그냥 실행 -> this는 전역객체를 참조   
call 메서드 이용 -> 임의의 객체를 this로 지정할 수 있음.    

### apply 메서드
apply 메서드 : call 메서드와 기능적으로 완전히 동일. 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다.    

`call` 이나 `apply` 메서드를 이용해서 유사배열객체에서 배열 메서드를 차용할 수 있다. ES6에서는 Array.from 메서드를 도입하여 유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환 가능하게했다.   
call/apply 메서드는 명시적으로 별도의 this를 바인딩하면서 함수 또는 메서드를 실행하는 방법이지만, 오히려 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있다.   

### bind 메서드
bind 메서드 : ES5에서 추가. call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드.   
bind 메서드의 두 가지 목적 : bind 메서드는 함수에 this를 미리적용하는 것, 부분 적용 함수를 구현하는 것.     

### 화살표 함수의 예외사항
ES6에 새롭게 도입된 화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외됐다. 화살표 함수 내부에는 this가 아예 없으며, 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 된다.   
화살표 함수를 이용하면 별도의 변수로 this를 우회하거나 call/apply/bind를 적용할 필요가 없어 더욱 간결하고 편리하다.    
