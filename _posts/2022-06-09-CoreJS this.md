---
layout: single
title: "CoreJS this"
---

# this
대부분의 객체지향 언어에서 this는 클래스로 생성한 인스턴스 객체를 의미한다. 자바스크립트에서의 this는 어디서든 사용할 수 있다. 상황에 따라 this가 바라보는 대상이 달라진다.     
함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.      

자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 생성 된다. 즉 **this는 함수를 호출할 때 결정**된다.   

### 전역 공간에서의 this
전역 공간에서 this는 전역 객체를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문.   

브라우저 환경 : window    
Node.js 환경 : global     

**전역 공간에서 발생하는 특징** : 전역변수를 선언하면 JS엔진은 이를 전역객체의 프로퍼티로도 할당한다. 변수이면서 객체의 프로퍼티인 셈.   

**자바스크립트의 모든 변수는 특정 객체의 프로퍼티**로서 동작 한다. 특정 객체란 실행 컨텍스트의 `LexicalEnvironment` 이다. 실행 컨텍스트는 변수를 수집해서 L.E의 프로퍼티로 저장한다. 전역 컨텍스트의 경우 L.E는 전역객체를 그대로 참조한다.    

### 메서드로서 호출할 때 그 메서드 내부에서의 this
어떤 함수를 실행하는 가장 일반적인 방법 : 함수로서 호출, 메서드로서 호출    

#### 함수 vs 메서드
함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 **독립성**에 있다.     
함수 : 그 자체로 독립적인 기능을 수행
메서드 : 자신을 호출한 대상 객체에 관한 동작을 수행      

어떤 함수를 객체의 프로퍼티에 할당한다고 무조건 메서드가 되는것이 아니라, `메서드`는 객체의 메서드로서 호출할 경우에 `메서드`로 동작하고, 그렇지 않으면 `함수`로 동작한다.     

#### '함수로서 호출'과 '메서드로서 호출'을 어떻게 구분 할까?
함수 앞에 점(.)이 있는지 여부로 구분할 수 있다. 함수 앞에 점이 없으면 함수로서 호출, method 앞에 점이 있으면 메서드로서 호출한 것!   
(대괄호 표기법에서는 함수 이름 앞에 객체가 명시돼 있는 경우에 메서드로 호출한 것.)      

#### 메서드 내부에서의 this
`this`에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 `this`가 되는 것.    

### 함수로서 호출할 때 그 함수 내부에서의 this
함수 내부에서의 this : 함수에서의 `this`는 전역 객체를 가리킨다.    
메서드의 내부함수에서의 this : 내부함수를 함수로서 호출한 것이면 전역객체, 메서드로서 호출한 것이면 점(.) 앞의 객체를 바라본다.      

#### this를 바인딩하지 않는 함수
ES5에서는 변수에 this를 저장해서 내부함수에서 활용하는 방법으로 this를 우회했다. ES6에서는 this를 바인딩하지 않는 화살표 함수(arrow function)를 새로 도입했다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다.    

### 콜백 함수 호출 시 그 함수 내부에서의 this
**콜백 함수란?** 함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라고 부른다.     

콜백 함수를 호출할 때 대상이 될 this를 지정하지 않은 경우의 this는 전역객체를 바라본다.    
어떠한 메서드가 콜백 함수를 호출할 때 자신의 this를 상속한다면 메서드명의 점(.) 앞부분이 곧 this가 된다.     

### 생성자 함수 내부에서의 this
