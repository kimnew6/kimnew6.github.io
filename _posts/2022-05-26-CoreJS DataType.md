---
layout: single
title: "CoreJS 1. DataType"
---

# 데이터 타입
**데이터 타입에는 크게 두 가지가 있다. 기본형(원시형,primitive type)과 참조형(reference type)이다.**     

<img width="505" alt="스크린샷 2022-05-26 오후 3 56 04" src="https://user-images.githubusercontent.com/84711115/170434664-e86bb3e3-9cb7-41f1-8fad-74094c5c9b80.png">

기본형 : 숫자(number), 문자열(string), 불리언(boolean), null, undefined + ES6의 심볼(Symbol)    
참조형 : 객체(object), 배열(Array), 함수(Function), 날짜(Date), 정규표현식(RegExp) + ES6의 Map, WeakMap, Set, WeakSet

#### 기본형과 참조형을 구분하는 기준은?
기본형은 값이 담긴 주솟값을 바로 복제한다.    
참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

### 식별자와 변수
변수(variable) : 변할 수 있는 수. **변할 수 있는 무언가**. 여기서 '무언가'란 **데이터**를 말한다.     
식별자(identifier) : 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명**이다.

### 변수 선언
```js
// 예제 1-1
var a
```
예제 1-1을 말로 풀어쓰면 "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"가 된다. 변수란 **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**이라고 생각할 수 있다.
### 데이터 할당
```js
// 예제 1-2 변수 선언과 할당
var a;          // 변수 a 선언
a= 'abc'        // 변수 a에 데이터 할당

var a = 'abc';  // 변수 선언과 할당을 한 문장으로 표현
```
예제 1-2의 2, 3번째 줄과 같이 두 문장으로 나누어 명령하든 5번째 줄과 같이 한 문장으로 명령하든, 자바스크립트 엔진은 결국 같은 동작을 수행한다.   
      
<img width="579" alt="스크린샷 2022-05-26 오후 4 25 43" src="https://user-images.githubusercontent.com/84711115/170439259-9cb90bea-5dd7-448c-aa85-4ef325f56fff.png">
      
1. 변수 영역에서 빈 공간(@1003)을 확보한다.
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장한다.
4. 변수 영역에서 a라는 식별자를 검색한다(@1003).
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

**왜 변수 영역에 값을 직접 대입하지 않고 굳이 번거롭게 한 단계를 더 거치는 걸까?** 이는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위한 고민의 결과이다.    
문자열 'abc'의 마지막에 'def'를 추가하라고 하면 컴퓨터는 앞서 'abc'가 저장된 공간에 'abcdef'를 할당하는 대신 'abcdef'라는 문자열을 **새로** 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결한다.      
      
<img width="516" alt="스크린샷 2022-05-26 오후 4 32 40" src="https://user-images.githubusercontent.com/84711115/170440410-378acd04-9655-4820-a243-d62c32d1bf2f.png">
      
### 불변값
변수(variable)와 상수(constant)를 구분하는 성질은 '변경 가능성'이다. 바꿀 수 있으면 변수, 바꿀 수 없으면 상수이다.    
변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다. 한 번 데이터 할당이 이루어진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다. 반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.   

기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다.
```js
// 예제 1-3 불변성
var a = 'abc';
a = a + 'def';

var b = 5;
var c = 5;
b = 7;
```

변수 a에 문자열 'abc'를 할당했다가 뒤에 'def'를 추가하면 기존의 'abc'가 'abcdef'로 바뀌는 것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장한다. 'abc'와 'abcdef'는 완전히 별개의 데이터이다.     

5번째 줄에서는 변수 b에 숫자 5를 할당한다. 컴퓨터는 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어 저장한다. 그 주소를 b에 저장한다.   
6번째 줄에서는 같은 수인 5를 할당하려고 한다. 컴퓨터는 데이터 영역에서 5를 찾고, 4번째 줄에서 이미 만들어 놓은 값이 있으니 그 주소를 재활용한다.      
7번째 줄에서는 변수 b의 값을 7로 바꾸고자 한다. 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라 기존에 저장했던 7을 찾고, 있으면 재활용하고 없으면 새로 만들어서 b에 저장한다. 결국 5와 7 모두 다른 값으로 변경할 수 없다.    
    
이처럼 문자열 값, 숫자 값은 한 번 만든 값을 바꿀 수 없다. 변경은 새로 만드는 동작을 통해서만 이루어진다. 이것이 **불변값**의 성질이다.     

### 가변값
#### 기본형 데이터는 모두 불변값이라 했는데, 참조형 데이터는 모두 가변값일까?
기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다.

```js
// 예제 1-4 참조형 데이터의 할당
var obj1 = {
    a: 1,
    b: 'bbb'
};
```
      
<img width="536" alt="스크린샷 2022-05-26 오후 4 50 58" src="https://user-images.githubusercontent.com/84711115/170443455-8b31a6b5-c3be-43f3-a415-1fa266455269.png">
      
1. 컴퓨터는 우선 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 obj1로 지정한다.
2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역 의 주소(@7103 ~ ?)를 @5001에 저장한다.
3.  @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정한다.
4.  데이터 영역에서 숫자 1을 검색한다. 검색 결과가 없으므로 임의로 @5003에 저장하고, 이 주소 를 @7103에 저장한다. 문자열 'bbb' 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장한다.

기본형 데이터와의 차이는 `객체의 변수(프로퍼티) 영역`이 별도로 존재한다는 점이다. 객체가 별도로 할애한 영역은 변수 영역일 뿐 `데이터 영역`은 기존의 메모리 공간을 그대로 활용하고 있다. 데이터 여역에 저장된 값은 모두 **불변값**이다. 그러나 변수에는 다른 값을 얼마든지 대입할 수 있다. 바로 이 부분 때문에 흔히 참조형 데이터는 `불변(immutable)하지 않다(가변값이다)`라고 하는 것이다.
      
```js
// 예제 1-5 참조형 데이터의 프로퍼티 재할당
var obj1 = {
    a: 1,
    b: 'bbb'
};
obj1.a = 2;
```
      
obj1의 a 프로퍼티에 숫자 2를 할당하려고 한다. 데이터 영역에서 숫자 2를 검색, 검색 결과가 없으므로 빈 공간인 @5005에 저장하고, 이 주소를 @7103에 저장한다. 6번째 줄의 명령 전과 후에 변수 obj1이 바라보고 있는 주소는 @5001로 변하지 않았다. 즉 `새로운 객체`가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것이다.     
      
<img width="546" alt="스크린샷 2022-05-26 오후 5 51 37" src="https://user-images.githubusercontent.com/84711115/170454065-814bfc1e-700c-4fd6-81a0-c6cf9cdc68f1.png">
      
